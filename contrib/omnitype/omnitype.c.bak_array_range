#include "postgres.h"
#include "fmgr.h"

#include "funcapi.h"
#include "mb/pg_wchar.h"
#include "lib/stringinfo.h"
#include "nodes/nodes.h"      // 包含 NodeTag 类型定义
#include "nodes/pg_list.h"    // 包含 List 和 String 类型定义
#include "nodes/parsenodes.h" // 包含 String 结构体定义
#include "utils/builtins.h"
#include "utils/regproc.h"
#include "utils/lsyscache.h"

// #include "utils/bpchar.h"
// #include "utils/varchar.h"
#include "utils/bytea.h"
#include "utils/jsonb.h"
#include "utils/varlena.h"
#include "utils/xml.h"
#include "utils/timestamp.h"
#include "utils/date.h"
#include "utils/inet.h"
#include "utils/varbit.h"
#include "tsearch/ts_locale.h"
#include "tsearch/ts_utils.h"
#include "utils/uuid.h"
#include "utils/array.h"
#include "utils/rangetypes.h"
#include "tsearch/ts_locale.h"
#include "tsearch/ts_utils.h"

#include "utils/syscache.h"
#include "catalog/pg_collation_d.h"
#include "catalog/pg_namespace_d.h"

PG_MODULE_MAGIC;

/* _PG_init、_PG_fini 必须唯一，通常放在插件主 .c 文件中 */
void _PG_init(void);
void _PG_init(void)
{
    MemoryContext oldctx = MemoryContextSwitchTo(TopMemoryContext);

    // 注册类型和函数

    MemoryContextSwitchTo(oldctx);
}

void _PG_fini(void);
void
_PG_fini(void)
{
}

/**********************************
 * composite data type
 **********************************/

// #define COMPOSITE_DEEPCOPY 1 // 是否使用深拷贝

typedef enum CompositeIndex {
    COM_TEXT = 0,
    COM_VARCHAR,
    COM_CHAR,
    COM_BYTEA,
    COM_JSON,
    COM_XML,
    COM_TIME,
    COM_DATE,
    COM_INET,
    COM_BIT,
    COM_TSVECTOR,
    COM_UUID,
    COM_ARRAY,
    COM_RANGE,
    COM_LEN // 总字段数，目前是14
} CompositeIndex;

#ifndef USE_LIBXML // 编译时需启用 --with-libxml（依赖 libxml 库）
typedef struct varlena xmltype;
#endif

/* 复合类型结构体定义 */
typedef struct Composite {
    text        *f1_text;
    VarChar     *f2_varchar;
    BpChar      *f3_char;
    bytea       *f4_bytea;  // 字符串以 \\x 开头
    Jsonb       *f5_json;
    xmltype     *f6_xml;
    Timestamp   f7_time;    // 时间类型
    DateADT     f8_date;    // 日期类型
    inet        *f9_net;    // 网络地址
    VarBit      *f10_bit;   // 位串
    TSVector    f11_tsvec;  // 文本搜索
    pg_uuid_t   *f12_uuid;  // UUID
    ArrayType   *f13_array; // 数组
    RangeType   *f14_range; // 范围类型
} Composite;

bool field_is_null(char **fields, CompositeIndex pos)
{
    if (strlen(fields[pos]) == 0 || strcmp(fields[pos], "NULL") == 0)
        return true;
    return false;
}

PG_FUNCTION_INFO_V1(composite_out);
Datum
composite_out(PG_FUNCTION_ARGS)
{
    Composite  *comp = (Composite *) PG_GETARG_POINTER(0);
    StringInfoData str;

    initStringInfo(&str);

    /* f1_text */
    appendStringInfoString(&str, TextDatumGetCString(PointerGetDatum(comp->f1_text)));
    appendStringInfoChar(&str, '|');

    /* f2_varchar(128) */
    Datum varchar_datum = DirectFunctionCall1(varcharout, PointerGetDatum(comp->f2_varchar));
    char *varchar_str = DatumGetCString(varchar_datum);
    appendStringInfoString(&str, varchar_str);
    pfree(varchar_str);
    appendStringInfoChar(&str, '|');

    /* f3_char(256) */
    Datum bpchar_datum = DirectFunctionCall1(bpcharout, PointerGetDatum(comp->f3_char));
    char *bpchar_str = DatumGetCString(bpchar_datum);
    appendStringInfoString(&str, bpchar_str);
    pfree(bpchar_str);
    appendStringInfoChar(&str, '|');

    /* f4_bytea */
    Datum bytea_datum = DirectFunctionCall1(byteaout, PointerGetDatum(comp->f4_bytea));
    char *bytea_str = DatumGetCString(bytea_datum);
    appendStringInfoString(&str, bytea_str);
    pfree(bytea_str);
    appendStringInfoChar(&str, '|');

    /* f5_json */
    Datum jsonb_datum = DirectFunctionCall1(jsonb_out, PointerGetDatum(comp->f5_json));
    char *json_str = DatumGetCString(jsonb_datum);
    appendStringInfoString(&str, json_str);
    pfree(json_str);
    appendStringInfoChar(&str, '|');

    /* f6_xml */
    if (comp->f6_xml) {
#ifdef USE_LIBXML // 编译时需启用 --with-libxml（依赖 libxml 库）
        Datum xml_datum = DirectFunctionCall1(xml_out, PointerGetDatum(comp->f6_xml));
        char *xml_str = DatumGetCString(xml_datum);
        appendStringInfoString(&str, xml_str);
        pfree(xml_str);
#else
        Datum xml_datum = DirectFunctionCall1(varcharout, PointerGetDatum(comp->f6_xml));
        char *xml_str = DatumGetCString(xml_datum);
        appendStringInfoString(&str, xml_str);
        pfree(xml_str);
#endif
    }
    appendStringInfoChar(&str, '|');

    // f7_time
    if (!TIMESTAMP_NOT_FINITE(comp->f7_time)) {
        Datum time_datum = DirectFunctionCall1(timestamp_out, TimestampGetDatum(comp->f7_time));
        appendStringInfoString(&str, DatumGetCString(time_datum));
        pfree(DatumGetPointer(time_datum));
    } else {
        appendStringInfoString(&str, "infinity");
    }
    appendStringInfoChar(&str, '|');

    // f8_date
    Datum date_datum = DirectFunctionCall1(date_out, DateADTGetDatum(comp->f8_date));
    appendStringInfoString(&str, DatumGetCString(date_datum));
    pfree(DatumGetPointer(date_datum));
    appendStringInfoChar(&str, '|');

    // f9_net
    if (comp->f9_net) {
        Datum net_datum = DirectFunctionCall1(inet_out, PointerGetDatum(comp->f9_net));
        appendStringInfoString(&str, DatumGetCString(net_datum));
        pfree(DatumGetPointer(net_datum));
    } else {
        appendStringInfoString(&str, "NULL");
    }
    appendStringInfoChar(&str, '|');

    // f10_bit
    if (comp->f10_bit) {
        Datum bit_datum = DirectFunctionCall1(bit_out, PointerGetDatum(comp->f10_bit));
        appendStringInfoString(&str, DatumGetCString(bit_datum));
        pfree(DatumGetPointer(bit_datum));
    }
    appendStringInfoChar(&str, '|');

    // f11_tsvec
    if (comp->f11_tsvec) {
        Datum ts_datum = DirectFunctionCall1Coll(tsvectorout,
                                                PG_GET_COLLATION(), /* 显式指定 collation */
                                                TSVectorGetDatum(comp->f11_tsvec));
        appendStringInfoString(&str, DatumGetCString(ts_datum));
        pfree(DatumGetPointer(ts_datum));
    }
    appendStringInfoChar(&str, '|');

    // f12_uuid
    if (comp->f12_uuid) {
        Datum uuid_datum = DirectFunctionCall1(uuid_out, PointerGetDatum(comp->f12_uuid));
        appendStringInfoString(&str, DatumGetCString(uuid_datum));
        pfree(DatumGetPointer(uuid_datum));
    }
    appendStringInfoChar(&str, '|');

    // f13_array
    if (comp->f13_array) {
        Datum array_datum = DirectFunctionCall1(array_out, PointerGetDatum(comp->f13_array));
        appendStringInfoString(&str, DatumGetCString(array_datum));
        pfree(DatumGetPointer(array_datum));
    }
    appendStringInfoChar(&str, '|');

    // f14_range
    if (comp->f14_range) {
        Datum range_datum = DirectFunctionCall1(range_out, PointerGetDatum(comp->f14_range));
        appendStringInfoString(&str, DatumGetCString(range_datum));
        pfree(DatumGetPointer(range_datum));
    }

    PG_RETURN_CSTRING(str.data);
}

/* 数组有效性检查函数 */
static bool
array_input_is_valid(const char *str)
{
    /* 示例：检查基本格式 */
    return (str[0] == '{' && str[strlen(str)-1] == '}');
}

static Oid
get_array_in_oid(void)
{
    /* 参数类型列表：CSTRING, OID, INT4 */
    Oid arg_types[] = {CSTRINGOID, OIDOID, INT4OID};
    int nargs = sizeof(arg_types) / sizeof(Oid);

    /* 查询函数 OID */
    return GetSysCacheOid2(
        PROCNAMEARGSNSP,
        CStringGetDatum("array_in"),
        PointerGetDatum(buildoidvector(arg_types, nargs)),
        ObjectIdGetDatum(PG_CATALOG_NAMESPACE)
    );
}

PG_FUNCTION_INFO_V1(composite_in);
Datum
composite_in(PG_FUNCTION_ARGS)
{
    char       *input_str = PG_GETARG_CSTRING(0);
    Composite  *comp;
    List       *namelist = NIL;
    ListCell   *lc;
    char      **fields;
    int         nfields = 0;
    int         i = 0;

    /* 分割输入字符串 */
    /* 注意：
       1. SplitIdentifierString 函数中，namelist 中各个元素的内容是通过 nextp 指针
          直接在输入字符串 rawstring 上进行定位的，并没有使用动态内存分配函数来分配内存，
          因此，后面无需使用深拷贝释放这部分内存（强行释放会导致crash）。
       2. 包含空格的子串必须以 "" 标注。该函数默认会将空格及其他空白字符视为分隔符的一部分，
          这是因为该函数的设计初衷是解析 SQL 标识符，而 SQL 标识符通常不允许包含空格。 */
    if (!SplitIdentifierString(input_str, '|', &namelist))
        ereport(ERROR, (errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),
                        errmsg("invalid input syntax for composite type")));

    /* 验证字段数量 */
    nfields = list_length(namelist);
    if (nfields != COM_LEN) {
        list_free(namelist);
        ereport(ERROR, (errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),
                        errmsg("composite type requires exactly %d fields", COM_LEN)));
    }

    /* 转换 List 到字符数组 */
    fields = (char **) palloc(sizeof(char *) * COM_LEN);
    foreach(lc, namelist) {
        if (i >= COM_LEN)
            break;

#ifdef COMPOSITE_DEEPCOPY
        char *sval = (char *) lfirst(lc);
        fields[i] = pstrdup(sval); // 深拷贝方式
#else
        fields[i] = (char *) lfirst(lc); // 浅拷贝方式
#endif
        // 如果打开这行elog代码且设置 set client_min_messages=INFO; 后，会在 client 端输出如下上下文信息：
        // LINE 1: SELECT 'text|varchar|char|\xDEADBEEF|{"key":123}|<xml>data</...
        elog(INFO, "Field %d: %s", i, fields[i]); // for debug
        i++;
    }

    list_free(namelist); // 浅拷贝方式的释放

    comp = (Composite *) palloc0(sizeof(Composite));

    /* f1_text */
    comp->f1_text = cstring_to_text(fields[COM_TEXT]);  // 直接分配

    /* f2_varchar(128) */
    Datum varchar_datum =
        DirectFunctionCall3(varcharin, CStringGetDatum(fields[COM_VARCHAR]),
                            ObjectIdGetDatum(InvalidOid), Int32GetDatum(128));
    VarChar *varchar = DatumGetVarCharPP(varchar_datum);
    if (VARSIZE_ANY_EXHDR(varchar) > 128) {
        pfree(varchar);
        ereport(ERROR, (errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),
                        errmsg("value too long for varchar(128)")));
    }
    comp->f2_varchar = (VarChar *) palloc(VARSIZE(varchar));
    memcpy(comp->f2_varchar, varchar, VARSIZE(varchar));
    pfree(varchar);  // 释放临时对象

    /* f3_char(256) */
    Datum bpchar_datum = DirectFunctionCall3(
        bpcharin, CStringGetDatum(fields[COM_CHAR]), ObjectIdGetDatum(InvalidOid),
        Int32GetDatum(-1));  // 若 typmod 为 256，可能会输出很多空格，
                             // 而 -1 表示 bpcharin 函数根据 strlen 计算。
    BpChar *bpchar = DatumGetBpCharPP(bpchar_datum);
    if (VARSIZE_ANY_EXHDR(bpchar) > 256) { // 长度校验
        pfree(bpchar);
        ereport(ERROR, (errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),
                        errmsg("value too long for bpchar(256)")));
    }
    comp->f3_char = (BpChar *) palloc(VARSIZE(bpchar));
    memcpy(comp->f3_char, bpchar, VARSIZE(bpchar));
    pfree(bpchar);

    /* f4_bytea */
    if (strncmp(fields[COM_BYTEA], "\\x", 2) != 0) /* 格式检查，\\ 是一个字符 */
        ereport(ERROR, (errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),
                        errmsg("bytea input must start with \\x")));
    Datum bytea_datum = DirectFunctionCall1(byteain, CStringGetDatum(fields[COM_BYTEA]));
    bytea *bytea_val = DatumGetByteaPP(bytea_datum);
    comp->f4_bytea = (bytea *) palloc(VARSIZE(bytea_val));
    memcpy(comp->f4_bytea, bytea_val, VARSIZE(bytea_val));
    pfree(bytea_val);

    /* f5_json */
    Datum jsonb_datum = DirectFunctionCall1(jsonb_in, CStringGetDatum(fields[COM_JSON]));
    comp->f5_json = (Jsonb *) palloc(VARSIZE(DatumGetPointer(jsonb_datum)));
    memcpy(comp->f5_json, DatumGetPointer(jsonb_datum), VARSIZE(DatumGetPointer(jsonb_datum)));

    /* f6_xml */
    if (strlen(fields[COM_XML]) > 0) {
#ifdef USE_LIBXML // 编译时需启用 --with-libxml（依赖 libxml 库）
        Datum xml_datum = DirectFunctionCall1(xml_in, CStringGetDatum(fields[COM_XML]));
        comp->f6_xml = (xmltype *) palloc(VARSIZE(DatumGetPointer(xml_datum)));
        memcpy(comp->f6_xml, DatumGetPointer(xml_datum), VARSIZE(DatumGetPointer(xml_datum)));
#else
        Datum xml_datum =
            DirectFunctionCall3(varcharin, CStringGetDatum(fields[COM_XML]),
                                ObjectIdGetDatum(InvalidOid), Int32GetDatum(128));
      xmltype *xml = DatumGetVarCharPP(xml_datum);
      if (VARSIZE_ANY_EXHDR(xml) > 128) {
        pfree(xml);
        ereport(ERROR, (errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),
                        errmsg("value too long for xml(128)")));
        }
        comp->f6_xml = (xmltype *) palloc(VARSIZE(xml));
        memcpy(comp->f6_xml, xml, VARSIZE(xml));
        pfree(xml);  // 释放临时对象
#endif
    } else {
        comp->f6_xml = NULL;
    }

    // f7_time
    if (strcmp(fields[COM_TIME], "infinity") == 0) {
        comp->f7_time = DT_NOEND;
    } else {
        Datum time_datum =
            DirectFunctionCall3(timestamp_in, CStringGetDatum(fields[COM_TIME]),
                                ObjectIdGetDatum(InvalidOid), Int32GetDatum(-1));
      comp->f7_time = DatumGetTimestamp(time_datum);
    }

    // f8_date
    Datum date_datum = DirectFunctionCall1(date_in, CStringGetDatum(fields[COM_DATE]));
    comp->f8_date = DatumGetDateADT(date_datum);

    // f9_net
    if (strcmp(fields[COM_INET], "NULL") != 0) {
        Datum net_datum = DirectFunctionCall1(inet_in, CStringGetDatum(fields[COM_INET]));
        comp->f9_net = (inet *) palloc(sizeof(inet));
        memcpy(comp->f9_net, DatumGetPointer(net_datum), sizeof(inet));
    }

    // f10_bit
    if (strlen(fields[COM_BIT]) > 0) {
        Datum bit_datum =
            DirectFunctionCall3(bit_in, CStringGetDatum(fields[COM_BIT]),
                                ObjectIdGetDatum(InvalidOid), Int32GetDatum(-1));
      comp->f10_bit = (VarBit *)palloc(VARSIZE(DatumGetPointer(bit_datum)));
      memcpy(comp->f10_bit, DatumGetPointer(bit_datum),
             VARSIZE(DatumGetPointer(bit_datum)));
    }

    // f11_tsvec
    if (strlen(fields[COM_TSVECTOR]) > 0) {
        Datum ts_datum = DirectFunctionCall1(tsvectorin, CStringGetDatum(fields[COM_TSVECTOR]));
        comp->f11_tsvec = (TSVector) palloc(VARSIZE(DatumGetPointer(ts_datum)));
        memcpy(comp->f11_tsvec, DatumGetPointer(ts_datum), VARSIZE(DatumGetPointer(ts_datum)));
    }

    elog(INFO, "=======> f12"); // ==================
    // f12_uuid
    if (strlen(fields[COM_UUID]) > 0) {
        Datum uuid_datum = DirectFunctionCall1(uuid_in, CStringGetDatum(fields[COM_UUID]));
        comp->f12_uuid = (pg_uuid_t *) palloc(UUID_LEN);
        memcpy(comp->f12_uuid, DatumGetPointer(uuid_datum), UUID_LEN);
    }

    elog(INFO, "=======> f13"); // ==================
    // f13_array (示例：整数数组)
    if (strlen(fields[COM_ARRAY]) > 0) {
        /* 1. 输入有效性检查 */
        if (!array_input_is_valid(fields[COM_ARRAY])) {
            ereport(ERROR, (errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),
                            errmsg("invalid array input syntax")));
        }

        /* 2. 获取数组类型信息 */
        Oid element_type = INT4OID; // 假设数组元素类型为 int4
        int32 typmod = -1;
        Oid collation = PG_GET_COLLATION();
        Oid array_in_oid = get_array_in_oid();

        /* 3. 调用数组输入函数 */
        Datum array_datum = OidFunctionCall3Coll(
            array_in_oid, collation, CStringGetDatum(fields[COM_ARRAY]),
            ObjectIdGetDatum(element_type), Int32GetDatum(typmod));

        /* 4. 获取数组指针并计算大小 */
        ArrayType *src_array = DatumGetArrayTypeP(array_datum);
        int array_size = VARSIZE_ANY_EXHDR(src_array) + ARR_OVERHEAD_NONULLS(ARR_NDIM(src_array));

        /* 5. 分配内存并拷贝完整数组结构 */
        comp->f13_array = (ArrayType *) palloc(VARSIZE_ANY(src_array));
        memcpy(comp->f13_array, src_array, VARSIZE_ANY(src_array));

        /* 6. 清理临时内存 */
        pfree(src_array);
    }

    elog(INFO, "=======> f14"); // ==================
    // f14_range (示例：日期范围)
    if (strlen(fields[COM_RANGE]) > 0) {
        Oid range_type = DATERANGEOID; // 根据实际情况调整
        Datum range_datum = DirectFunctionCall3(
            range_in, CStringGetDatum(fields[COM_RANGE]),
            ObjectIdGetDatum(range_type), Int32GetDatum(-1));
        comp->f14_range = (RangeType *) palloc(VARSIZE(DatumGetPointer(range_datum)));
        memcpy(comp->f14_range, DatumGetPointer(range_datum), VARSIZE(DatumGetPointer(range_datum)));
    }
    elog(INFO, "=======> finish"); // ==================

    /* 清理临时字段数组 */
#ifdef COMPOSITE_DEEPCOPY
    for (i = 0; i < COM_LEN; i++) {
        elog(INFO, "Freeing field %d: %s", i, fields[i]);
        pfree(fields[i]);
    }
#endif
    pfree(fields);

    PG_RETURN_POINTER(comp);
}

static int
text_cmp(text *arg1, text *arg2, Oid collid)
{
	char	   *a1p,
			   *a2p;
	int			len1,
				len2;

	a1p = VARDATA_ANY(arg1);
	a2p = VARDATA_ANY(arg2);

	len1 = VARSIZE_ANY_EXHDR(arg1);
	len2 = VARSIZE_ANY_EXHDR(arg2);

	return varstr_cmp(a1p, len1, a2p, len2, collid);
}

PG_FUNCTION_INFO_V1(composite_cmp);
Datum composite_cmp(PG_FUNCTION_ARGS)
{
    Composite *a = (Composite *) PG_GETARG_POINTER(0);
    Composite *b = (Composite *) PG_GETARG_POINTER(1);
    int res;

    /* 按字段优先级顺序比较 */

    res = text_cmp(a->f1_text, b->f1_text, PG_GET_COLLATION());
    if (res) return res;

    res = DirectFunctionCall5(
        varstr_cmp, PointerGetDatum(a->f2_varchar),
        Int32GetDatum(VARSIZE_ANY_EXHDR(a->f2_varchar)), PointerGetDatum(b->f2_varchar),
        Int32GetDatum(VARSIZE_ANY_EXHDR(b->f2_varchar)), PG_GET_COLLATION());
    if (res) return res;

//     COMPARE_FIELD(f2_varchar, varstr_cmp);
//     COMPARE_FIELD(f3_char, bpchar_cmp);
//     COMPARE_FIELD(f4_bytea, byteacmp);
//     COMPARE_FIELD(f5_json, jsonb_cmp);
// #ifdef USE_LIBXML
//     COMPARE_FIELD(f6_xml, xml_cmp);
// #else
//     COMPARE_FIELD(f6_xml, strcmp);
// #endif
//     COMPARE_FIELD(f7_time, timestamp_cmp);
//     COMPARE_FIELD(f8_date, date_cmp);
//     COMPARE_FIELD(f9_net, network_cmp);
//     COMPARE_FIELD(f10_bit, bit_cmp);
//     COMPARE_FIELD(f11_tsvec, tsvector_cmp);
//     COMPARE_FIELD(f12_uuid, uuid_cmp);
//     COMPARE_FIELD(f13_array, array_cmp);
//     COMPARE_FIELD(f14_range, range_cmp);

    /* 所有字段相等返回0 */
    PG_RETURN_INT32(0);
}